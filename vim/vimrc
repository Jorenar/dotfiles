" XDG support {{{1

if empty($MYVIMRC) | let $MYVIMRC = expand('<sfile>:p') | endif

if empty($XDG_CACHE_HOME)  | let $XDG_CACHE_HOME  = $HOME."/.cache"       | endif
if empty($XDG_CONFIG_HOME) | let $XDG_CONFIG_HOME = $HOME."/.config"      | endif
if empty($XDG_DATA_HOME)   | let $XDG_DATA_HOME   = $HOME."/.local/share" | endif
if empty($XDG_STATE_HOME)  | let $XDG_STATE_HOME  = $HOME."/.local/state" | endif

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p', 0700)

set backupdir=$XDG_STATE_HOME/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$XDG_STATE_HOME/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$XDG_STATE_HOME/vim/undo     | call mkdir(&undodir,   'p', 0700)
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p', 0700)

if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif

" BASICS {{{1

set nocompatible
filetype plugin indent on
syntax enable
set backup undofile
colorscheme darkness

" Open file at the last known position
autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' | exec "norm! g`\"" | endif

" COMMANDS {{{1

com! -range -nargs=+  Align            <line1>,<line2>!column -Lts<args> -o<args>
com! -bang            ColorUp          set syntax=ON | exec "colo " . (<bang>0 ? "darkness" : "colorUp")
com!                  CountSpell       echo utils#CountSpell()
com!                  ExecCurrentLine  normal :.w !sh<CR>
com! -nargs=1         FillLine         exec "norm! $" | exec "FillToColumn" <q-args> &tw
com! -nargs=+         FillToColumn     exec {str,r -> "norm! a".repeat(str, (r-col("."))/len(str))}(<f-args>)
com! -nargs=+         Grep             silent! exec "grep -R <args> ."
com! -nargs=+         GrepRename       exec {a,b -> 'tabe | lv /\C\<' . a . '\>/j ** | cdo s/\C\<' . a . '\>/' . b . '/gc | up'}(<f-args>) | q
com!                  InstallPlugins   call utils#InstallPlugins()
com! -nargs=1         SetFormatProg    exec {prg -> 'let [ &l:formatprg, &l:formatexpr ] = [ "'.prg.' 2> /dev/null", "" ]'}(<args>)
com! -range=%         Sort             normal :<line1>,<line2>sort i<CR>
com! -nargs=?         Spelling         if empty("<args>") | setl spell! | else | setl spell spelllang=<args> | endif
com!                  SudoW            exec 'silent! write !sudo tee % >/dev/null' | edit!
com!                  SyntaxStack      echo join(reverse(map(synstack(line('.'), col('.')), 'synIDattr(v:val,"name")')),' ')
com! -nargs=+         Vimgrep          exec "vimgrep /".<q-args>."/j **"
com! -range           VisSort          sil! keepj <line1>,<line2>call utils#VisSort()

if has('nvim')
  cnoreabbrev term sp\|term
endif

" MAPPINGS {{{1

nnoremap ' `
nnoremap <expr> <F4> &ve == "all" ? ":set ve=\<CR>" : ":set ve=all\<CR>"
nnoremap <F10> :w <bar> make<CR>
nnoremap <F3> :set cursorline! cursorcolumn!<CR>
nnoremap <F7> :w <bar> silent! make %:p <bar> redraw!<CR>
nnoremap <Leader>= gg=G``
nnoremap <Leader>q m"gggqG`"
nnoremap <Leader>r :exec {o -> {n -> n != "" ? '%s/\C\<' . o . '\>/' . n . '/g' : ''}(input(o." > ", o))}(expand('<cword>'))<CR>
nnoremap <silent> <C-l> :nohlsearch<C-r>=has('diff')?'<bar>diffupdate':''<CR><CR><C-l>
nnoremap <silent> <F8> :if has("nvim") <bar> split <bar> endif <bar> term<CR>
nnoremap <silent> <Leader>b :bnext<CR>
nnoremap <silent> <Leader>B :bprev<CR>
nnoremap <silent> <Leader>w :<C-u>call softWrapLineAtCol#toggle(v:count ? v:count : &tw)<CR>
nnoremap j gj
nnoremap k gk

vnoremap iz :<C-u>silent! norm! [zjV]zk<CR>
onoremap iz :<C-u>silent! norm Viz<CR>
vnoremap az :<C-u>silent! norm! [zV]z<CR>
onoremap az :<C-u>silent! norm Vaz<CR>

inoremap <expr> <C-o> pumvisible() ? "\<C-n>" : "\<C-o>"

xnoremap # :<C-u>call utils#VSetSearch('?')<CR>?<C-r>=@/<CR><CR>
xnoremap * :<C-u>call utils#VSetSearch('/')<CR>/<C-r>=@/<CR><CR>

tnoremap <silent> <C-\><C-\> <C-\><C-n>

map gh <nop>

" OPTIONS {{{1

set keywordprg=:Man
set makeprg=Make
set modeline nomodelineexpr
set number
set scrolloff=5
set sessionoptions=blank,buffers,folds,tabpages,winsize
set shortmess+=I shortmess-=S
set spellsuggest=double,5
set splitbelow splitright
set ttimeoutlen=10
set vb t_vb=
set wildmenu wildmode=full wildoptions=
set updatetime=250

set colorcolumn=+1
set fillchars+=vert:│

set hidden
set switchbuf=usetab

set diffopt=internal,filler,closeoff,indent-heuristic,algorithm:histogram
let g:diff_translations = 0

set hlsearch
set ignorecase
set incsearch
set smartcase

set mouse=a
set mousemodel=popup_setpos
silent! set ttymouse=sgr

set list
set listchars=tab:<\ >,trail:_
set listchars+=extends:>,precedes:<
hi! ListCharsTabs ctermfg=235
autocmd BufWinEnter * call matchadd("ListCharsTabs", '\t')

set guioptions=c
set guicursor=a:block
let &guifont = has("win32") ? "Consolas:h11:cANSI:qDRAFT" : "DejaVu Sans Mono 11"

set title
set titlestring=
set titlestring+=%t%(\ %M%)%(\ (%{expand(\"%:p:~:.:h\")}/)%)
set titlestring+=\ \|\ %{$USER}@%{hostname()}:%{substitute(getcwd(),$HOME,'~','')}

set complete+=kspell
set completeopt=menuone,noinsert,noselect
set omnifunc=syntaxcomplete#Complete
set pumheight=20

set nowrap
set linebreak
set breakindent
let &showbreak = "↳  "

set path=**,./
set tags+=.tags/tags;

set backspace=indent,eol,start
set cindent
set expandtab
set shiftround
set shiftwidth=0   " If 0, then uses value of 'tabstop'
set softtabstop=-1 " If negative, then uses 'shiftwidth' (which can use 'tabstop')
set tabstop=4
set textwidth=80

set showcmd
set signcolumn=yes

set laststatus=2
set statusline=%!lines#StatusLine()

set showtabline=2
set tabline=%!lines#TabLine()

augroup FORMATOPTIONS
  autocmd!
  autocmd BufWinEnter * set fo-=c fo-=r fo-=o " Disable continuation of comments to the next line
  autocmd BufWinEnter * set formatoptions+=j  " Remove a comment leader when joining lines
  autocmd BufWinEnter * set formatoptions+=l  " Don't break a line after a one-letter word
  autocmd BufWinEnter * set formatoptions+=n  " Recognize numbered lists
  autocmd BufWinEnter * set formatoptions-=q  " Don't format comments
  autocmd BufWinEnter * set formatoptions-=t  " Don't autowrap text using 'textwidth'
augroup END

let g:filetype_cfg = "conf"

" folds {{{
set foldmethod=indent
set foldtext=MyFoldText()
set nofoldenable

" If file has more lines than window height, then fold it
autocmd BufReadPost * if line('$') > winheight(0) | setlocal fen | endif

function! MyFoldText() abort
  let line = getline(v:foldstart)
  let line = substitute(line, split(&l:fmr, ',')[0].'\d\?', '', '')
  let line = trim(line, " \t\r\n", 2)
  let line = strchars(line) > &tw/2 ? line[:(&tw/2)] . "..." : line
  let fd = repeat(v:folddashes, 2)
  let pad = &tw - strchars(line) - len(fd)

  return printf("%s  +%s %*.d lines ", line, fd, pad, v:foldend - v:foldstart + 1)
endfunction
" }}}

" terminal {{{
exec 'autocmd '.(has("nvim") ? "TermOpen" : "TerminalOpen").' *'
      \ . ' setlocal stl=%#StatusLineTerm#\ %{expand(\"%:t\")} '

if has('nvim') " sanitize Neovim :terminal
  autocmd TermOpen  * startinsert
  autocmd TermOpen  * set nonumber
  autocmd TermClose * call feedkeys("\<C-\>\<C-n>")
endif
" }}}

let g:syntax_off_exceptions = [ "help", "man", "markdown", "qf", "tex" ]
autocmd FileType *
      \   if index(g:syntax_off_exceptions, &ft) < 0
      \ |   silent! setlocal syntax=OFF
      \ | endif

" PLUGINS {{{1

let g:plugins = {
      \   "repos": [
      \     "chrisbra/NrrwRgn",
      \     "ctrlpvim/ctrlp.vim",
      \     "dense-analysis/ale",
      \     "editorconfig/editorconfig-vim",
      \     "Jorengarenar/miniSnip",
      \     "jpalardy/vim-slime",
      \     "junegunn/gv.vim",
      \     "markonm/traces.vim",
      \     "mbbill/undotree",
      \     "mhinz/vim-signify",
      \     "prabirshrestha/vim-lsp",
      \     "preservim/tagbar",
      \     "tpope/vim-fugitive",
      \   ],
      \   "files": [
      \     [ "autoload/lsp/ale.vim",  "github.com/rhysd/vim-lsp-ale/raw/master/autoload/lsp/ale.vim" ],
      \     [ "autoload/repeat.vim",   "github.com/tpope/vim-repeat/raw/master/autoload/repeat.vim" ],
      \     [ "plugin/commentary.vim", "github.com/tpope/vim-commentary/raw/master/plugin/commentary.vim" ],
      \     [ "plugin/eunuch.vim",     "github.com/tpope/vim-eunuch/raw/master/plugin/eunuch.vim" ],
      \     [ "plugin/rsi.vim",        "github.com/tpope/vim-rsi/raw/master/plugin/rsi.vim" ],
      \     [ "plugin/surround.vim",   "github.com/tpope/vim-surround/raw/master/plugin/surround.vim" ],
      \   ]
      \ }

packadd cfilter
packadd matchit
packadd termdebug
source  $VIMRUNTIME/ftplugin/man.vim

" ALE {{{2

let g:ale_disable_lsp = 1
let g:ale_echo_msg_format = '[%linter%]: %s'
let g:ale_set_signs = 0
let g:ale_virtualtext_cursor = 0

hi! link ALEError   Error
hi! link ALEWarning WarningMsg

nnoremap <F2> :ALEToggle<CR>

augroup LSP_ALE
  autocmd!
  autocmd User lsp_buffer_enabled
        \  call lsp#ale#enable()
        \| let b:ale_linters = get(b:, "ale_linters", []) + [ 'vim-lsp' ]
        \| ALELint

  let g:lsp_ale_diagnostics_severity = 'information'
  let g:lsp_ale_auto_enable_linter   = 0
augroup END

" vim-lsp {{{2

let g:lsp_diagnostics_highlights_delay       = 0
let g:lsp_diagnostics_highlights_enabled     = 1
let g:lsp_diagnostics_signs_enabled          = 0
let g:lsp_diagnostics_virtual_text_enabled   = 0
let g:lsp_document_code_action_signs_enabled = 0

let g:lsp_log_verbose = 0
let g:lsp_log_file = $XDG_STATE_HOME . "/vim/lsp.log"

hi! link LspErrorHighlight   Error
hi! link LspWarningHighlight WarningMsg

com! LspCallHierarchyIncomingTree  call lsp#call_hierarchy_tree#show(v:false)
com! LspCallHierarchyOutgoingTree  call lsp#call_hierarchy_tree#show(v:true)

function! s:lsp_init() abort
  setlocal omnifunc=lsp#complete

  nmap <buffer> <Leader>R <Plug>(lsp-rename)

  nmap <buffer> <Leader>gd <Plug>(lsp-definition)
  nmap <buffer> <Leader>gs <Plug>(lsp-document-symbol-search)
  nmap <buffer> <Leader>gS <Plug>(lsp-workspace-symbol-search)
  nmap <buffer> <Leader>gr <Plug>(lsp-references)
  nmap <buffer> <Leader>gi <Plug>(lsp-implementation)

  nmap <buffer> <Leader>kk <Plug>(lsp-hover)
  nmap <buffer> <Leader>kd <Plug>(lsp-peek-declaration)
  nmap <buffer> <Leader>kg <Plug>(lsp-peek-definition)
  nmap <buffer> <Leader>ki <Plug>(lsp-peek-implementation)
  nmap <buffer> <Leader>kt <Plug>(lsp-peek-type-definition)

  nnoremap <buffer> <expr><C-f> lsp#scroll(+4)
  nnoremap <buffer> <expr><C-d> lsp#scroll(-4)

  nnoremenu PopUp.LSP :popup ]LSP<CR>
  nnoremenu ]LSP.Hover       <Plug>(lsp-hover)
  nnoremenu ]LSP.Call\ Tree  :LspCallHierarchyIncomingTree<CR>
  nnoremenu ]LSP.[Peek]\ Definition  <Plug>(lsp-peek-definition)
  nnoremenu ]LSP.[Peek]\ Declaration <Plug>(lsp-peek-declaration)
  nnoremenu ]LSP.[Jump]\ Definition  <Plug>(lsp-definition)
  nnoremenu ]LSP.[Jump]\ Declaration <Plug>(lsp-declaration)
endfunction

augroup LSP
  autocmd!
  autocmd User lsp_buffer_enabled call s:lsp_init()

  if executable("ccls")
    au User lsp_setup call lsp#register_server(#{
          \   name: "ccls",
          \   cmd: [ "ccls" ],
          \   root_uri: {-> lsp#utils#path_to_uri(
          \     lsp#utils#find_nearest_parent_file_directory(
          \       lsp#utils#get_buffer_path(),
          \       [ "compile_commands.json", ".ccls", ".git/" ]
          \     )
          \   )},
          \   initialization_options: #{
          \     cache: #{ directory: "/tmp/ccls-cache" },
          \     clang: #{ extraArgs: [ "--gcc-toolchain=/usr" ] },
          \   },
          \   allowlist: [ "c", "cpp", "objc", "objcpp" ],
          \ })
  elseif executable('clangd')
    au User lsp_setup call lsp#register_server(#{
          \   name: "clangd",
          \   cmd: ["clangd",
          \     "--query-driver=/usr/bin/gcc",
          \     "--background-index",
          \     "--clang-tidy",
          \   ],
          \   allowlist: [ "c", "cpp", "objc", "objcpp" ],
          \ })
  endif

  if executable("jedi-language-server")
    au User lsp_setup call lsp#register_server(#{
          \   name: "Jedi",
          \   cmd: [ "jedi-language-server" ],
          \   allowlist: [ "python" ],
          \ })
  endif

  if executable("texlab")
    au User lsp_setup call lsp#register_server(#{
          \   name: "TexLab",
          \   cmd: [ "texlab" ],
          \   allowlist: [ "tex" ],
          \ })
  endif

  if executable("sqls")
    au User lsp_setup call lsp#register_server(#{
          \   name: "sqls",
          \   cmd: [ "sqls" ],
          \   command: "sqls",
          \   workspace_config: #{
          \     sqls: #{
          \       connections: [
          \         #{
          \           driver: "sqlite3",
          \           dataSourceName: $SQLS_SQLITE_DB,
          \         },
          \         #{
          \           driver: "mysql",
          \           proto:  "unix",
          \           user:   empty($SQLS_MYSQL_USER) ? $USER : $SQLS_MYSQL_USER,
          \           passwd: $SQLS_MYSQL_PASSWD,
          \           path:   "/run/mysqld/mysqld.sock",
          \           dbName: $SQLS_MYSQL_DB,
          \         },
          \       ],
          \     },
          \   },
          \   allowlist: [ "sql" ]
          \ })
  endif

  if executable("jdtls")
    au User lsp_setup call lsp#register_server(#{
          \   name: "Eclipse JDT Language Server",
          \   cmd: [ "jdtls" ],
          \   allowlist: [ "java" ],
          \ })
  endif

  if executable("deno")
    au User lsp_setup call lsp#register_server(#{
          \   name: "Deno",
          \   cmd: [ "deno", "lsp" ],
          \   initialization_options: #{
          \     config: $XDG_CONFIG_HOME . "/deno.json",
          \     enable: v:true,
          \     unstable: v:true,
          \     lint: v:true,
          \     codeLens: #{
          \       implementations: v:true,
          \       references: v:true,
          \       referencesAllFunctions: v:true,
          \       test: v:true,
          \     },
          \     suggest: #{
          \       names: v:true,
          \     },
          \   },
          \   allowlist: [ "javascript", "typescript" ],
          \ })
  endif

augroup END

" Surround {{{2

let g:surround_no_mappings = 1

xmap s  <Plug>VSurround
nmap s  <Plug>Ysurround
nmap ds <Plug>Dsurround
nmap cs <Plug>Csurround
nmap ss <Plug>Yssurround

" CtrlP {{{2

let g:ctrlp_cache_dir  = $XDG_CACHE_HOME . "/vim/ctrlp"
let g:ctrlp_types      = [ "fil", "buf" ]
let g:ctrlp_extensions = [ "tag", "line" ]

let g:ctrlp_prompt_mappings = {
      \ "PrtExit()":     [ "<Esc>" ],
      \ "PrtHistory(1)": [ "<C-f>" ],
      \ "ToggleType(1)": [ "<C-p>", "<C-Up>" ],
      \ }

" Netrw {{{2

let g:netrw_banner       = 0    " do not display info on the top of window
let g:netrw_liststyle    = 3    " tree-view
let g:netrw_browse_split = 4    " use the previous window to open file
let g:netrw_winsize      = -28  " window size

augroup NETRW_CONF
  autocmd!
  autocmd filetype netrw silent! unmap <buffer> <F1>
  autocmd filetype netrw silent! unmap <buffer> <C-l>
  autocmd filetype netrw setlocal statusline=%f
augroup END

" Tagbar {{{2

nnoremap <Leader>t :Tagbar<CR>

let g:tagbar_sort = 0
let g:tagbar_compact = 1
let g:tagbar_ctags_options = [ split(&rtp,",")[0].'/ctags.cnf' ]

hi! link TagbarNestedKind Comment
hi! link TagbarType Comment

let g:tagbar_type_vb = #{
      \   kinds: [
      \     'T:types',
      \     's:subroutines',
      \     'f:functions',
      \     'E:events',
      \     'v:variables',
      \     'c:constants',
      \     'p:properties',
      \     'e:enum',
      \   ]
      \ }

" vim-slime {{{2

let g:slime_dont_ask_default = 1
let g:slime_no_mappings = 1
let g:slime_paste_file = tempname()

if has("nvim")
  let g:slime_target = "neovim"
elseif has("terminal")
  let g:slime_target = "vimterminal"
elseif executable("tmux")
  let g:slime_target = "tmux"
elseif !empty($DISPLAY)
  let g:slime_target = "x11"
endif

function! Slimeify()
  let g:slime_default_config = get(g:, "slime_default_config", {})

  let foo = {
        \   "vimterminal": [ "bufnr", "bufnr()"  ],
        \   "neovim":      [ "jobid", "&channel" ],
        \ }

  let st = get(g:, "slime_target", "")
  if has_key(foo, st)
    let [ target, y ] = foo[st]
    let g:slime_default_config[target] = eval(y)
  endif
endfunction

com! -nargs=+ -bang  Slime  call slime#send(<q-args> . (<bang>0 ? "" : "\r"))

noremap  <F5> :SlimeSend<CR>
tnoremap <F5> <C-\><C-n>:call Slimeify()<CR>a

" ~ {{{2

let g:termdebug_wide = 1

let g:EditorConfig_enable_for_new_buf = 1

let g:traces_preview_window = "new"

let g:fastfold_fold_command_suffixes  = [ 'C', 'm', 'M', 'N', 'x', 'X' ]
let g:fastfold_fold_movement_commands = []
let g:fastfold_minlines = 0
let g:fastfold_savehook = 0

let g:miniSnip_extends = {
      \   "arduino"  : [ "cpp", "c" ],
      \   "cpp"      : [ "c" ],
      \   "html"     : [ "css", "javascript" ],
      \   "markdown" : [ "html" ],
      \   "php"      : [ "html" ],
      \   "tex"      : [ "plaintex" ],
      \ }

let g:undotree_SetFocusWhenToggle = 1
nnoremap <F1> :UndotreeToggle<CR>

let g:signify_sign_change = '~'
highlight link  SignifySignChange  DiffText

" }}}2

" ~ {{{1

nnoremenu PopUp.[gd] gd
nnoremenu PopUp.:call :popup ]call<CR>
nnoremenu ]call.popup_clear() :call popup_clear()<CR>

nnoremenu PopUp.:grep :silent! grep -RIw <cword> .<CR>

if has("cscope") && (executable("cscope") || executable("gtags-cscope"))
  set cscopetag
  set cscopetagorder=0
  set cscopepathcomp=2
  set cscopequickfix=a-,c-,d-,e-,f-,g-,i-,s-,t-

  call cscope#init()
endif

augroup MERGETOOL
  autocmd!
  if join(argv()) =~ '.*_LOCAL_.*_BASE_.*_REMOTE_.*'
    autocmd BufReadPost  *_LOCAL_*   setl stl=\ LOCAL
    autocmd BufReadPost  *_BASE_*    setl stl=\ BASE
    autocmd BufReadPost  *_REMOTE_*  setl stl=\ REMOTE
  endif
augroup END

augroup TRIM_TRAILING_WHITESPACE
  autocmd!
  autocmd BufWritePre * sil! undoj | sil! keepp keepj %s/\v(\s+$|\_s+%$)//e
augroup END

augroup NO_NESTED_VIM
  autocmd!

  if !has("nvim") && $vimInstanceExists
    au BufNewFile,BufReadPre * exec 'bd | !printf "\033]51;[\"drop\", \"'. expand('%:p') . '\"]\007"' | q
  endif
  let $vimInstanceExists = 1

augroup END

augroup VISUALBLOCK_NOSTARTOFLINE
  autocmd!
  exec "autocmd ModeChanged *:\<C-v> let g:sol_old = &sol | set nosol"
  exec "autocmd ModeChanged \<C-v>:* let &startofline = g:sol_old"
augroup END

augroup OTHER
  autocmd!

  " Automatically open QuickFix
  autocmd QuickFixCmdPost [^l]* nested cwindow
  autocmd QuickFixCmdPost    l* nested lwindow

  " Undo if filter shell command returned an error
  autocmd ShellFilterPost * if v:shell_error | undo | endif

  " Set fold method to syntax
  autocmd FileType conf,dosini,make,m3u,todo  setlocal foldmethod=syntax

augroup END

silent! helptags ALL

set secure exrc
