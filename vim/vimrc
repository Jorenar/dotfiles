" # VIMRC #

" BASICS {{{1

filetype plugin indent on
set backspace=indent,eol,start
set nocompatible
syntax enable

" XDG support
set backupdir=$XDG_DATA_HOME/vim/backup
set directory=$XDG_CACHE_HOME/vim/swap
set packpath^=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim,$XDG_CONFIG_HOME/vim/after
set undodir=$XDG_CACHE_HOME/vim/undo
set viminfo+=n$XDG_CACHE_HOME/vim/viminfo

" Set colorscheme
colorscheme darkness

" AUTOCMDS {{{1

" Open file at the last known position
autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' | exe "normal! g`\"" | endif

" Disable continuation of comments to the next line
autocmd BufReadPost * set fo-=c fo-=r fo-=o

" Trim trailing whitespace
autocmd BufWritePre * silent! undojoin | %s/\s\+$//e | %s/\(\n\r\?\)\+\%$//e

" Set .h to be of C filetype
autocmd BufRead,BufNewFile *.h set filetype=c

" Set 'foldmethod' to 'syntax'
autocmd filetype css,html,java,javascript,sh setlocal foldmethod=syntax

" Protect folds when toggling insert mode / switching windows
autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

" Automatically open QuickFix
autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow

" Terminal options
autocmd TerminalWinOpen * setlocal nonumber | autocmd WinEnter <buffer> silent! normal i

" Local vimrc
autocmd BufReadPost * if filereadable("./.vimrc.local") | source ./.vimrc.local | endif

" COMMANDS {{{1

command! -nargs=* GrepRename call <SID>GrepRename(<f-args>)
command! -nargs=+ FillLine call <SID>FillLine(<f-args>)
command! -nargs=+ Grep execute "vimgrep /<args>/j ** | :copen"
command! -nargs=+ Spelling execute 'setlocal spell spelllang=<args>'
command! -range -nargs=+ Align <line1>,<line2>!column -Lts'<args>' -o'<args>'
command! -range -nargs=0 -bang VisSort sil! keepj <line1>,<line2>call <SID>VisSort(<bang>0)
command! -range=% Sort normal :<line1>,<line2>sort i<CR>
command! ExecCurrentLine normal :.w !sh<CR>
command! FileSize echo getfsize(expand(@%))
command! Make call s:Make()
command! SortBlock :normal! vip:sort i<CR>
command! UndoList call s:UndoList()

" COMPILE AND RUN {{{1

let s:compiler_for_filetype = {
            \ "c,cpp"    : "gcc",
            \ "go"       : "go",
            \ "haskell"  : "ghc",
            \ "html"     : "tidy",
            \ "perl"     : "perl",
            \ "php"      : "php",
            \ "plaintex" : "tex",
            \ "python"   : "pyunit",
            \ "tex"      : "tex",
            \}

let s:makeprg_for_filetype = {
            \ "asm"      : "as -o %<.o % && ld -s -o %< %<.o && rm %<.o && ./%<",
            \ "basic"    : "vintbas %",
            \ "c"        : "gcc -std=gnu11 -g % -o %< && ./%<",
            \ "cpp"      : "g++ -std=gnu++11 -g % -o %< && ./%<",
            \ "go"       : "go build && ./%<",
            \ "haskell"  : "ghc -o %< %; rm %<.hi %<.o && ./%<",
            \ "html"     : "tidy -quiet -errors --gnu-emacs yes %:S; firefox -new-window % &",
            \ "lisp"     : "clisp %",
            \ "lua"      : "lua %",
            \ "markdown" : "grip --quiet -b %",
            \ "nasm"     : "yasm -f elf64 % && ld -g -o %< %<.o && rm %<.o && ./%<",
            \ "perl"     : "perl %",
            \ "plaintex" : "pdftex -file-line-error -interaction=nonstopmode % && zathura %<.pdf",
            \ "python"   : "python %",
            \ "rust"     : "rustc % && ./%<",
            \ "sh"       : "chmod +x %:p && %:p",
            \ "tex"      : "pdflatex -file-line-error -interaction=nonstopmode % && zathura %<.pdf",
            \ "xhtml"    : "tidy -asxhtml -quiet -errors --gnu-emacs yes %:S; firefox -new-window % &",
            \}

let &shellpipe="2> >(tee %s)"

for [ft, comp] in items(s:compiler_for_filetype)
    execute "autocmd filetype ".ft." compiler! ".comp
endfor

for [ft, mp] in items(s:makeprg_for_filetype)
    execute 'autocmd filetype '.ft.' let &l:makeprg="('.mp.')"'
endfor

" FORMATTING {{{1

let g:html_indent_autotags = "html"
let g:html_indent_style1 = "inc"
set autoindent
set cindent
set expandtab
set formatoptions-=t
set shiftround
set shiftwidth=4
set softtabstop=4
set tabstop=4
set textwidth=79

let s:tab_width_for_filetype = {
            \ "html,css,xhtml,xml" : 2,
            \ "javascript"         : 2,
            \ "lua"                : 2,
            \ "markdown"           : 2,
            \}

let s:formatprg_for_filetype = {
            \ "c,cpp"      : "astyle --style=kr -s4 -N -S -xG -xU -k3 -p -O -c",
            \ "css"        : "css-beautify -s 2 --space-around-combinator",
            \ "go"         : "gofmt",
            \ "html"       : "tidy -q -w -i --show-warnings 0 --show-errors 0 --tidy-mark no",
            \ "java"       : "astyle --style=java -s4 -N -S -xG -xU -f -k3 -xj -p",
            \ "javascript" : "js-beautify -s 2",
            \ "json"       : "js-beautify",
            \ "python"     : "autopep8 -",
            \ "sql"        : "sqlformat -k upper -r -",
            \ "xhtml"      : "tidy -asxhtml -q -m -w -i --show-warnings 0 --show-errors 0 --tidy-mark no --doctype loose",
            \ "xml"        : "tidy -xml -q -m -w -i --show-warnings 0 --show-errors 0 --tidy-mark no",
            \}

for [ft, fp] in items(s:formatprg_for_filetype)
    execute "autocmd filetype ".ft." let &l:formatprg=\"".fp."\" | setlocal formatexpr="
endfor

for [ft, width] in items(s:tab_width_for_filetype)
    execute "autocmd filetype ".ft." setlocal tabstop=".width." shiftwidth=".width." softtabstop=".width
endfor

" FUNCTIONS {{{1
" GrepRename - replace through whole project {{{2
function! s:GrepRename(expr1, expr2) abort
    execute "tabe | vimgrep /\\C\\W".a:expr1."\\W/j ** | cdo s/\\C\\\(\\W\\)".a:expr1."\\\(\\W\\)/\\1".a:expr2."\\2/gc | update" | q
endfunction

" FileEncoding ~ for Status line {{{2
function! FileEncoding() abort
    return (&fenc == "" ? &enc : &fenc).((exists("+bomb") && &bomb) ? " BOM" : "")
endfunction

" FileSize     ~ for Status Line{{{2
function! FileSize() abort
    let bytes = getfsize(expand(@%))
    if (bytes >= 1024*1024)
        return printf('~%.1f MiB', bytes/(1024*1024.0))
    elseif (bytes >= 1024)
        return printf('~%.1f KiB', bytes/1024.0)
    elseif (bytes <= 0)
        return '0 B'
    else
        return bytes . ' B'
    endif
endfunction

" FillLine - fill line with characters to given column {{{2
function! s:FillLine(str, ...) abort
    let to_column = get(a:, 1, &tw)
    let reps = (to_column - col("$")) / len(a:str)
    if reps > 0
        .s/$/\=(' '.repeat(a:str, reps))/
    endif
endfunction

" Make {{{2
function! s:Make() abort
    let l:makeprg_temp = &makeprg
    let &l:makeprg = "make $*"
    make
    let &l:makeprg = l:makeprg_temp
endfunction

" UndoList {{{2
function! s:UndoList() abort
    let name = " ".expand('%')."\n\n"
    let parent0 = bufnr()
    let list = execute('undolist')
    silent! bdelete! UndoList
    silent! topleft 30 vnew UndoList
    let b:parent = parent0
    let b:pattern = '^\s*\(\d*\)\s'
    setlocal nonumber buftype=nofile bufhidden=hide noswapfile
    setlocal statusline=\ UndoList
    put=list
    g/^/m3 | noh
    3,$norm elde
    silent! 3,$s/\(.*\ \ \)\@!\s\d*$//g | 3s/saved
    silent! %s/\s\+$//e
    normal ggdj
    put! =name
    setlocal nomodifiable
    autocmd WinEnter <buffer> if winnr('$') == 1 | q | endif
    nnoremap <buffer> <CR> :exec winbufnr(b:parent)."wincmd w <bar> undo ".matchstr(getline('.'), b:pattern)<CR>
endfunction

" VisSort - sorts based on visual-block selected portion of the lines {{{2
function! s:VisSort(isnmbr) range abort
    if visualmode() != "\<c-v>"
        execute "silent! ".a:firstline.",".a:lastline."sort i"
        return
    endif
    let firstline = line("'<")
    let lastline  = line("'>")
    let keeprega  = @a
    silent normal! gv"ay
    '<,'>s/^/@@@/
    silent! keepjumps normal! '<0"aP
    if a:isnmbr
        silent! '<,'>s/^\s\+/\=substitute(submatch(0),' ','0','g')/
    endif
    execute "sil! keepj '<,'>sort i"
    execute "sil! keepj ".firstline.",".lastline.'s/^.\{-}@@@//'
    let @a = keeprega
endfun

" VSetSearch - Search for selected text, forwards or backwards. {{{2
function! s:VSetSearch(cmdtype) abort
    let temp = @s
    norm! gv"sy
    let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
    let @s = temp
endfunction

" MAPPINGS {{{1
" Normal mode {{{2
nnoremap ' `
nnoremap '' ``
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <expr> <F4> &virtualedit == "all" ? ":set virtualedit=\<CR>" : ":set virtualedit=all\<CR>"
nnoremap <F3> :set cursorline! cursorcolumn!<CR>
nnoremap <F9> :w <bar> make<CR>
nnoremap <leader>= gg=G``
nnoremap <leader>` :redraw!<CR>
nnoremap <leader>h :nohlsearch<CR>
nnoremap <leader>q gggqG
nnoremap <leader>r :%s/\<<C-r><C-w>\>//g<Left><Left>
nnoremap <leader>R :%s/\<<C-r><C-w>\>/<C-r><C-w>/g<Left><Left>
nnoremap <leader>v ggVG
nnoremap <silent> <expr> <F5> g:colors_name == "darkness" ? ":syntax reset <bar> let g:colors_name=''\<CR>" : ":colo darkness\<CR>"
nnoremap gf <C-w>gf
nnoremap gx :execute 'silent! !xdg-open "<cfile>" &> /dev/null &' <bar> redraw! <CR>
nnoremap j gj
nnoremap k gk

" Terminal mode {{{2
tnoremap <C-h> <C-\><C-n><C-w>h
tnoremap <C-j> <C-\><C-n><C-w>j
tnoremap <C-k> <C-\><C-n><C-w>k
tnoremap <C-l> <C-\><C-n><C-w>l

" Visual mode {{{2
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>
xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>

" ### DISABLE {{{2
map gh <nop>
vmap s <nop>

" OPTIONS {{{1

let g:netrw_dirhistmax = 0
let g:netrw_winsize = -28
set backup
set colorcolumn=+1,+21
set completeopt=menuone,noinsert,noselect
set cursorlineopt=screenline
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set linebreak
set modeline
set nomodelineexpr
set nowrap
set number
set omnifunc=syntaxcomplete#Complete
set scrolloff=5
set sessionoptions=blank,buffers,folds,tabpages,winsize,terminal
set shortmess+=I
set showcmd
set smartcase
set splitbelow
set splitright
set t_TE= t_TI= " Disable modifyOtherKeys
set title
set undofile
set wildmenu

let g:sh_fold_enabled=5
set foldmethod=indent
set nofoldenable

set dictionary+=/usr/share/dict/polish
set dictionary+=/usr/share/dict/words
set path=**,./
set tags+=.git/tags;/

" PLUGINS {{{1

if empty(glob(substitute(&packpath, ",.*", "/pack/plugins/opt/minPlug", ""))) " {{{2
    call system("git clone --depth=1 https://github.com/Jorengarenar/minPlug ".substitute(&packpath, ",.*", "/pack/plugins/opt/minPlug", ""))
    autocmd VimEnter * silent! MinPlugInstall | echo "minPlug: INSTALLED"
endif " }}}

packadd minPlug

MinPlug Jorengarenar/fauxClip
MinPlug Jorengarenar/vim-darkness
MinPlug sirver/ultisnips
MinPlug tpope/vim-surround

" VARIABLES
let g:UltiSnipsEditSplit          = "context"
let g:UltiSnipsExpandTrigger      = "<C-j>"
let g:UltiSnipsListSnippets       = "<C-k>"
let g:UltiSnipsSnippetDirectories = [$VIMDOTDIR.'/UltiSnips']

" MAPPINGS
nmap s ys
vmap s S

" STATUS LINE {{{1

set statusline=
set statusline+=\ %f                " Relative path to the file
set statusline+=\ \                 " Separator
set statusline+=%y                  " Filetype
set statusline+=[%{&ff}]            " File format
set statusline+=[%{FileEncoding()}] " File encoding
set statusline+=\ \                 " Separator
set statusline+=[%{&fo}]            " Format options
set statusline+=\ \                 " Separator
set statusline+=[%{FileSize()}]     " File size
set statusline+=\ \                 " Separator
set statusline+=%r                  " Readonly flag
set statusline+=%w                  " Preview flag
set statusline+=\ \                 " Separator
set statusline+=%m                  " Modified flag
set statusline+=%=                  " Switch to the right side
set statusline+=[0x%B]\             " Current char hex code
set statusline+=%l/                 " Current line
set statusline+=%L                  " Total lines
set statusline+=\ \:\ %c\           " Current column

" ### OTHER {{{1

packadd matchit
call mkdir(&backupdir, 'p')

" vim: fdm=marker foldenable:
