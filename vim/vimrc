" XDG support {{{1

if empty($MYVIMRC) | let $MYVIMRC = expand('<sfile>:p') | endif

if empty($XDG_CACHE_HOME)  | let $XDG_CACHE_HOME  = $HOME."/.cache"       | endif
if empty($XDG_CONFIG_HOME) | let $XDG_CONFIG_HOME = $HOME."/.config"      | endif
if empty($XDG_DATA_HOME)   | let $XDG_DATA_HOME   = $HOME."/.local/share" | endif
if empty($XDG_STATE_HOME)  | let $XDG_STATE_HOME  = $HOME."/.local/state" | endif

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p', 0700)

set backupdir=$XDG_STATE_HOME/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$XDG_STATE_HOME/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$XDG_STATE_HOME/vim/undo     | call mkdir(&undodir,   'p', 0700)
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p', 0700)

if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif

" BASICS {{{1

set nocompatible
set backup undofile
filetype plugin indent on

syntax enable
autocmd FileType * silent! setlocal syntax=OFF
autocmd FileType * call matchadd("Todo", "TODO")

colorscheme minimal

" Open file at the last known position
autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' | exec "norm! g`\"" | endif

" Automatically open QuickFix
autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow

" Undo if filter shell command returned an error
autocmd ShellFilterPost * if v:shell_error | undo | endif

augroup NO_NESTED_VIM
  autocmd!
  if !has("nvim") && $vimInstanceExists
    au BufNewFile,BufReadPre * exec 'bd | !printf "\033]51;[\"drop\", \"'. expand('%:p') . '\"]\007"' | q
  endif
  let $vimInstanceExists = 1
augroup END

" COMMANDS {{{1

com! -nargs=+  FillLine  exec {str,r -> "norm! a".repeat(str, (r-col(".")+1)/len(str))}(<f-args>, &tw)
com! -range=%  Sort      normal :<line1>,<line2>sort i<CR>
com! -nargs=?  Spelling  if empty("<args>") | setl spell! | else | setl spell spelllang=<args> | endif
com! -range    VisSort   sil! keepj <line1>,<line2>call utils#misc#VisSort()

" MAPPINGS {{{1

nnoremap ' `
nnoremap <C-l> :nohlsearch<C-r>=has('diff')?'<bar>diffupdate':''<CR><CR><C-l>
nnoremap <expr> <C-e> utils#misc#scroll_cursor_popup(1) ? "<Esc>" : "<C-e>"
nnoremap <expr> <C-y> utils#misc#scroll_cursor_popup(-1) ? "<Esc>" : "<C-y>"
nnoremap <F3> <Cmd>set cursorline! cursorcolumn!<CR>
nnoremap <F4> <Cmd>let &ve = (&ve == "all" ? "" : "all")<CR>
nnoremap <F8> :if has("nvim") <bar> split <bar> endif <bar> term<CR>
nnoremap <Leader>= gg=G``
nnoremap <Leader>b <Cmd>bnext<CR>
nnoremap <Leader>q m"gggqG`"
nnoremap <Leader>r :exec {o -> {n -> n != "" ? '%s/\C\<' . o . '\>/' . n . '/g' : ''}(input(o." > ", o))}(expand('<cword>'))<CR>
nnoremap [C  <Cmd>call utils#motion#jump_DiffAdd(-1)<CR>
nnoremap ]C  <Cmd>call utils#motion#jump_DiffAdd(1)<CR>
nnoremap j gj
nnoremap k gk

vnoremap iz :<C-u>silent! norm! [zjV]zk<CR>
onoremap iz :<C-u>silent! norm Viz<CR>
vnoremap az :<C-u>silent! norm! [zV]z<CR>
onoremap az :<C-u>silent! norm Vaz<CR>

inoremap <expr> <C-o> pumvisible() ? "\<C-n>" : "\<C-o>"

xnoremap # :<C-u>call utils#motion#VSetSearch('?')<CR>?<C-r>=@/<CR><CR>
xnoremap * :<C-u>call utils#motion#VSetSearch('/')<CR>/<C-r>=@/<CR><CR>

cnoremap <C-h> <C-w>

tnoremap <silent> <C-\><C-\> <C-\><C-n>

map gh <nop>

" OPTIONS {{{1

set keywordprg=:Man
set makeprg=Make

set modeline nomodelineexpr
set number
set quickfixtextfunc=utils#texts#QuickFixTextFunc
set scrolloff=5
set sessionoptions=blank,buffers,folds,tabpages,winsize
set shortmess+=I shortmess-=S
set spellsuggest=double,5
set splitbelow splitright
set ttimeoutlen=10
set updatetime=250
set visualbell t_vb=

set path=**,./
set tags+=.tags/tags;

set wildmenu
set wildmode=full
set wildoptions=

set colorcolumn=+1
set fillchars+=vert:│

set hidden
set switchbuf=usetab

set diffopt=internal,filler,closeoff,indent-heuristic,algorithm:histogram
let g:diff_translations = 0

set hlsearch
set ignorecase
set incsearch
set smartcase

set mouse=a
set mousemodel=popup_setpos
silent! set ttymouse=sgr

set list
set listchars=tab:<\ >,trail:_
set listchars+=extends:>,precedes:<
hi! ListCharsTabs ctermfg=235
autocmd VimEnter,WinNew * call matchadd("ListCharsTabs", '\t')

set title
set titlestring=
set titlestring+=%t%(\ %M%)%(\ (%{expand(\"%:p:~:.:h\")}/)%)
set titlestring+=\ \|\ %{$USER}@%{hostname()}:%{substitute(getcwd(),$HOME,'~','')}

set complete+=kspell
set completeopt=menuone,noinsert,noselect
set omnifunc=syntaxcomplete#Complete
set pumheight=20

set nowrap
set linebreak
set breakindent
let &showbreak = "↳  "

set backspace=indent,eol,start
set cindent
set expandtab
set shiftround
set shiftwidth=0   " If 0, then uses value of 'tabstop'
set softtabstop=-1 " If negative, then uses 'shiftwidth' (which can use 'tabstop')
set tabstop=4
set textwidth=80

set showcmd
set signcolumn=yes

set laststatus=2
set statusline=%!utils#lines#StatusLine()

set showtabline=2
set tabline=%!utils#lines#TabLine()

set foldcolumn=2
set foldmethod=indent
set foldtext=utils#texts#FoldText()
set nofoldenable
autocmd BufReadPost * if line('$') > winheight(0) | setlocal fen | endif

augroup FORMATOPTIONS
  autocmd!
  autocmd BufWinEnter * set fo-=c fo-=r fo-=o " Disable continuation of comments to the next line
  autocmd BufWinEnter * set formatoptions+=j  " Remove a comment leader when joining lines
  autocmd BufWinEnter * set formatoptions+=l  " Don't break a line after a one-letter word
  autocmd BufWinEnter * set formatoptions+=n  " Recognize numbered lists
  autocmd BufWinEnter * set formatoptions-=q  " Don't format comments
  autocmd BufWinEnter * set formatoptions-=t  " Don't autowrap text using 'textwidth'
augroup END

augroup TERMINAL_OPTIONS
  autocmd!

  exec 'autocmd '.(has("nvim") ? "TermOpen" : "TerminalOpen").' *'
        \ . ' setlocal stl=%#StatusLineTerm#\ %{expand(\"%:t\")} '

  if has('nvim') " sanitize Neovim :terminal
    autocmd TermOpen * setlocal nonumber
    autocmd TermOpen * exec "e # | sb" bufnr()
          \| autocmd WinResized * ++once wincmd j | call feedkeys("A")
    autocmd TermClose * call feedkeys("\<C-\>\<C-n>")
  endif
augroup END

if has("cscope") && (executable("cscope") || executable("gtags-cscope"))
  set cscopetag
  set cscopetagorder=0
  set cscopepathcomp=2
  set cscopequickfix=a-,c-,d-,e-,f-,g-,i-,s-,t-

  packadd cscope_init
endif

augroup VISUALBLOCK_NOSTARTOFLINE
  autocmd!
  silent! exec "autocmd ModeChanged *:\<C-v> let g:sol_old = &sol | set nosol"
  silent! exec "autocmd ModeChanged \<C-v>:* let &startofline = g:sol_old"
augroup END

augroup MERGETOOL
  autocmd!
  if join(argv()) =~ '.*_LOCAL_.*_BASE_.*_REMOTE_.*'
    autocmd BufReadPost  *_LOCAL_*   setl stl=\ LOCAL
    autocmd BufReadPost  *_BASE_*    setl stl=\ BASE
    autocmd BufReadPost  *_REMOTE_*  setl stl=\ REMOTE
  endif
augroup END

" PLUGINS {{{1

packadd cfilter
packadd matchit
packadd termdebug
packadd editorconfig
source  $VIMRUNTIME/ftplugin/man.vim

" ALE {{{2

let g:ale_disable_lsp = 1
let g:ale_echo_msg_format = '[%linter%]: %s'
let g:ale_set_signs = 0
let g:ale_virtualtext_cursor = 0

hi! link ALEError   Error
hi! link ALEWarning WarningMsg

let g:lsp_ale_diagnostics_severity = 'information'

" vim-lsp {{{2

let g:lsp_use_native_client                  = 1

let g:lsp_diagnostics_highlights_delay       = 0
let g:lsp_diagnostics_highlights_enabled     = 1
let g:lsp_diagnostics_signs_enabled          = 0
let g:lsp_diagnostics_virtual_text_enabled   = 0
let g:lsp_document_code_action_signs_enabled = 0
let g:lsp_document_symbol_detail             = 1
let g:lsp_text_edit_enabled                  = 0

let g:lsp_log_verbose = 0
let g:lsp_log_file = $XDG_STATE_HOME . "/vim/lsp.log"

hi! link LspErrorHighlight   Error
hi! link LspWarningHighlight WarningMsg

com! LspCallHierarchyIncomingTree  call lsp#call_hierarchy_tree#show(v:false)
com! LspCallHierarchyOutgoingTree  call lsp#call_hierarchy_tree#show(v:true)

nnoremap L <Cmd>call inputsecret("No LSP server running for this buffer ")<CR>

function! s:lsp_init() abort
  setlocal omnifunc=lsp#complete

  nnoremap <buffer> L <Cmd>exec {l -> empty(l) ? '' : 'norm L'.l}(input("L"))<CR>

  nmap <buffer> LK <Plug>(lsp-hover)
  nmap <buffer> LR <Plug>(lsp-rename)

  nmap <buffer> Lgg <Plug>(lsp-definition)
  nmap <buffer> Lgd <Plug>(lsp-declaration)
  nmap <buffer> Lgi <Plug>(lsp-implementation)
  nmap <buffer> Lgt <Plug>(lsp-type-definition)

  nmap <buffer> Lkg <Plug>(lsp-peek-definition)
  nmap <buffer> Lkd <Plug>(lsp-peek-declaration)
  nmap <buffer> Lki <Plug>(lsp-peek-implementation)
  nmap <buffer> Lkt <Plug>(lsp-peek-type-definition)

  nmap <buffer> Lfr <Plug>(lsp-references)
  nmap <buffer> Lfs <Plug>(lsp-document-symbol-search)
  nmap <buffer> LfS <Plug>(lsp-workspace-symbol-search)
  nmap <buffer> Lfi <Plug>(lsp-call-hierarchy-incoming)
  nmap <buffer> Lfo <Plug>(lsp-call-hierarchy-outgoing)
endfunction

augroup LSP
  autocmd!
  autocmd User lsp_buffer_enabled call s:lsp_init()
  runtime! lsp-servers.vim
augroup END

" Surround {{{2

let g:surround_no_mappings = 1

xmap s  <Plug>VSurround
nmap s  <Plug>Ysurround
nmap ds <Plug>Dsurround
nmap cs <Plug>Csurround
nmap ss <Plug>Yssurround

" CtrlP (+ FZF) {{{2

let g:ctrlp_cache_dir     = $XDG_CACHE_HOME . "/vim/ctrlp"
let g:ctrlp_types         = [ "fil", "buf", "mru" ]
let g:ctrlp_extensions    = [ "tag", "line" ]
let g:ctrlp_mruf_relative = 1
let g:ctrlp_mruf_exclude  = '/tmp/.*\|/temp/.*'
let g:ctrlp_map           = '<C-p><C-p>'

let g:ctrlp_prompt_mappings = {
      \ "PrtExit()":     [ "<Esc>" ],
      \ "PrtHistory(1)": [ "<C-f>" ],
      \ "ToggleType(1)": [ "<C-p>", "<C-Up>" ],
      \ }

nnoremap <C-p><C-b> <Cmd>CtrlPBuf<CR>
nnoremap <C-p><C-l> <Cmd>CtrlPLine<CR>
nnoremap <C-p><C-m> <Cmd>CtrlPMRU<CR>
nnoremap <C-p><C-t> <Cmd>CtrlPTag<CR>

if executable("fzf")
  if index(g:ctrlp_types, "fil") >= 0
    call remove(g:ctrlp_types, index(g:ctrlp_types, "fil"))
    exec "nnoremap" g:ctrlp_map "<Cmd>FZF<CR>"
    let g:ctrlp_map = ''
  endif

  let g:fzf_layout = { 'down': '10' }

  augroup FZF
    autocmd!
    autocmd FileType fzf setl laststatus=0 | au BufLeave <buffer> setl ls=2
    autocmd FileType fzf tmap <buffer> <C-p> <C-c><Cmd>sleep 1m<CR><Cmd>CtrlP<CR>
  augroup END
endif

" Netrw {{{2

let g:netrw_banner       = 0    " do not display info on the top of window
let g:netrw_liststyle    = 3    " tree-view
let g:netrw_browse_split = 4    " use the previous window to open file
let g:netrw_winsize      = -28  " window size

augroup NETRW_CONF
  autocmd!
  autocmd filetype netrw silent! unmap <buffer> <F1>
  autocmd filetype netrw silent! unmap <buffer> <C-l>
  autocmd filetype netrw setlocal statusline=%f
augroup END

" Tagbar {{{2

nnoremap <Leader>t :Tagbar<CR>

let g:tagbar_sort = 0
let g:tagbar_compact = 1
let g:tagbar_ctags_options = [ split(&rtp,",")[0].'/ctags.cnf' ]

hi! link TagbarNestedKind Comment
hi! link TagbarType Comment

let g:tagbar_type_vb = #{
      \   kinds: [
      \     'T:types',
      \     's:subroutines',
      \     'f:functions',
      \     'E:events',
      \     'v:variables',
      \     'c:constants',
      \     'p:properties',
      \     'e:enum',
      \   ]
      \ }

" vim-bookmarks {{{2

let g:bookmark_auto_save_file = $XDG_STATE_HOME . "/vim/bookmarks"
let g:bookmark_disable_ctrlp = 1
let g:bookmark_display_annotation = 1
let g:bookmark_no_default_key_mappings = 1

nmap <Leader>mm  <Plug>BookmarkToggle
nmap <Leader>mi  <Plug>BookmarkAnnotate
nmap <Leader>ma  <Plug>BookmarkShowAll
nmap <Leader>m[  <Plug>BookmarkPrev
nmap <Leader>m]  <Plug>BookmarkNext
nmap <Leader>mk  <Plug>BookmarkMoveUp
nmap <Leader>mj  <Plug>BookmarkMoveDown
nmap <Leader>mg  <Plug>BookmarkMoveToLine

" Vim Tmux Navigator {{{2

let g:tmux_navigator_no_mappings = 1

noremap <silent> <C-w>h  <Cmd>TmuxNavigateLeft<CR>
noremap <silent> <C-w>j  <Cmd>TmuxNavigateDown<CR>
noremap <silent> <C-w>k  <Cmd>TmuxNavigateUp<CR>
noremap <silent> <C-w>l  <Cmd>TmuxNavigateRight<CR>

noremap <silent> <C-w><C-h>  <Cmd>TmuxNavigateLeft<CR>
noremap <silent> <C-w><C-j>  <Cmd>TmuxNavigateDown<CR>
noremap <silent> <C-w><C-k>  <Cmd>TmuxNavigateUp<CR>
noremap <silent> <C-w><C-l>  <Cmd>TmuxNavigateRight<CR>

" vim-slime {{{2

let g:slime_dont_ask_default = 1
let g:slime_no_mappings = 1
let g:slime_paste_file = tempname()

if has("nvim")
  let g:slime_target = "neovim"
elseif has("terminal")
  let g:slime_target = "vimterminal"
elseif executable("tmux")
  let g:slime_target = "tmux"
elseif !empty($DISPLAY)
  let g:slime_target = "x11"
endif

function! Slimeify()
  let g:slime_default_config = get(g:, "slime_default_config", {})

  let foo = {
        \   "vimterminal": [ "bufnr", "bufnr()"  ],
        \   "neovim":      [ "jobid", "&channel" ],
        \ }

  let st = get(g:, "slime_target", "")
  if has_key(foo, st)
    let [ target, y ] = foo[st]
    let g:slime_default_config[target] = eval(y)
  endif
endfunction

com! -nargs=+ -bang  Slime  call slime#send(<q-args> . (<bang>0 ? "" : "\r"))

noremap  <F5> :SlimeSend<CR>
tnoremap <F5> <C-\><C-n>:call Slimeify()<CR>a

" asyncrun.vim {{{2

let g:asyncrun_open = 10

nnoremap <F7> <Cmd>w <bar> AsyncRun -program=make %:p<CR>
nnoremap <F10> <Cmd>w <bar> AsyncRun -program=make<CR>

autocmd User AsyncRunStop copen | wincmd p

command! -nargs=? Make AsyncRun -program=make <args>

" ~ {{{2

let g:termdebug_wide = 1

let g:EditorConfig_enable_for_new_buf = 1

let g:traces_preview_window = "new"

let g:miniSnip_extends = {
      \   "arduino"  : [ "cpp", "c" ],
      \   "cpp"      : [ "c" ],
      \   "html"     : [ "css", "javascript" ],
      \   "markdown" : [ "html" ],
      \   "php"      : [ "html" ],
      \   "tex"      : [ "plaintex" ],
      \ }

let g:undotree_SetFocusWhenToggle = 1
nnoremap <F1> :UndotreeToggle<CR>

let g:signify_sign_change = '~'
highlight link  SignifySignChange  DiffText

" }}}2

" ~ {{{1

if has("gui_running") | runtime! gvimrc | endif
silent! helptags ALL
set secure exrc
