" XDG support {{{1

if empty($MYVIMRC) | let $MYVIMRC = expand('<sfile>:p') | endif

if empty($XDG_CACHE_HOME)  | let $XDG_CACHE_HOME  = $HOME."/.cache"       | endif
if empty($XDG_CONFIG_HOME) | let $XDG_CONFIG_HOME = $HOME."/.config"      | endif
if empty($XDG_DATA_HOME)   | let $XDG_DATA_HOME   = $HOME."/.local/share" | endif

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p', 0700)
set viewdir=$XDG_DATA_HOME/vim/view | call mkdir(&viewdir, 'p', 0700)

set backupdir=$XDG_CACHE_HOME/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$XDG_CACHE_HOME/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$XDG_CACHE_HOME/vim/undo     | call mkdir(&undodir,   'p', 0700)

if !has('nvim') | set viminfofile=$XDG_CACHE_HOME/vim/viminfo | endif

" BASICS {{{1

set nocompatible
filetype plugin indent on
syntax enable
silent! helptags ALL " genereate help tags
colorscheme darkness

" COMMANDS {{{1

com! -range -nargs=+  Align            <line1>,<line2>!column -Lts'<args>' -o'<args>'
com! -bang            ColorUp          exec "colo " . (<bang>0 ? "darkness" : "colorUp")
com!                  CountSpell       echo utils#CountSpell()
com!                  ExecCurrentLine  normal :.w !sh<CR>
com! -nargs=1         FillLine         exec "norm! $" | exec "FillToColumn" <q-args> &tw
com! -nargs=+         FillToColumn     exec {str,r -> "norm! a".repeat(str, (r-col("."))/len(str))}(<f-args>)
com! -nargs=+         Grep             exec "lvimgrep /".<q-args>."/j **"
com! -nargs=+         GrepRename       exec {a,b -> 'tabe | lv /\C\<' . a . '\>/j ** | ldo s/\C\<' . a . '\>/' . b . '/gc | up'}(<f-args>) | q
com!                  InstallPlugins   call utils#InstallPlugins()
com! -nargs=1         SetFormatProg    exec {prg -> 'let [ &l:formatprg, &l:formatexpr ] = [ "'.prg.'", "" ]'}(<args>)
com! -range=%         Sort             normal :<line1>,<line2>sort i<CR>
com!                  SortBlock        normal! vip:sort i<CR>
com! -nargs=? -bang   Spelling         setlocal spell<bang> spelllang=<args>
com!                  SudoW            exec 'silent! write !sudo tee % >/dev/null' | edit!
com!                  SyntaxStack      echo join(reverse(map(synstack(line('.'), col('.')), 'synIDattr(v:val,"name")')),' ')
com! -range           VisSort          sil! keepj <line1>,<line2>call utils#VisSort()

com! -nargs=1 -bang -complete=file  TermEF  call utils#TermEF("<args>")

if has('nvim')
  cnoreabbrev term sp\|term
endif

" MAPPINGS {{{1

nnoremap ' `
nnoremap <expr> <F4> &ve == "all" ? ":set ve=\<CR>" : ":set ve=all\<CR>"
nnoremap <F10> :w <bar> make<CR>
nnoremap <F3> :set cursorline! cursorcolumn!<CR>
nnoremap <F7> :w <bar> silent! make %:p <bar> redraw!<CR>
nnoremap <F8> :if has("nvim") <bar> split <bar> endif <bar> term<CR>
nnoremap <Leader>= gg=G``
nnoremap <Leader>b :bnext<CR>
nnoremap <Leader>h :nohlsearch<CR>
nnoremap <Leader>q m"gggqG`"
nnoremap <Leader>r :exec {o -> {n -> n != "" ? '%s/\C\<' . o . '\>/' . n . '/g' : ''}(input(o." > ", o))}(expand('<cword>'))<CR>
nnoremap <M-a> :cwindow<CR>
nnoremap j gj
nnoremap k gk

inoremap <expr> <C-o> pumvisible() ? "\<C-n>" : "\<C-o>"

xnoremap # :<C-u>call utils#VSetSearch('?')<CR>?<C-r>=@/<CR><CR>
xnoremap * :<C-u>call utils#VSetSearch('/')<CR>/<C-r>=@/<CR><CR>

tnoremap <silent> <C-\><C-\> <C-\><C-n>
tnoremap <silent> <C-\><C-m> <C-\><C-n>:let b:auto_insert = !b:auto_insert<CR>

imap <Esc>[29~ <nop>
map  <Esc>[29~ <nop>
map gh <nop>

" OPTIONS {{{1

set backspace=indent,eol,start
set backup
set colorcolumn=+1,+21,+31
set complete+=kspell
set hidden
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set makeprg=Make
set modeline nomodelineexpr
set nowrap
set number
set scrolloff=5
set sessionoptions=blank,buffers,folds,tabpages,winsize
set shortmess+=I
set showcmd
set smartcase
set spellsuggest=double
set splitbelow splitright
set switchbuf=usetab
set title
set undofile
set vb t_vb=
set wildmenu wildmode=full

set completeopt=menuone,noinsert,noselect
set omnifunc=syntaxcomplete#Complete
set pumheight=20

set linebreak
set breakindent
let &showbreak = "â†³  "

if has('nvim')
  set guicursor=n-v-c-sm-i-r-ci-ve-cr-o:block " setting a:block breaks blinking
  set wildoptions-=pum " don't use popupmenu for wildmode completion
endif

set path=**,./
set tags+=.git/tags;

augroup FORMATOPTIONS
  autocmd!
  autocmd FileType * set fo-=c fo-=r fo-=o " Disable continuation of comments to the next line
  autocmd FileType * set formatoptions+=j  " Remove a comment leader when joining lines
  autocmd FileType * set formatoptions+=l  " Don't break a line after a one-letter word
  autocmd FileType * set formatoptions+=n  " Recognize numbered lists
  autocmd FileType * set formatoptions-=q  " Don't format comments
  autocmd FileType * set formatoptions-=t  " Don't autowrap text using 'textwidth'
augroup END

set cindent
set expandtab
set shiftround
set shiftwidth=0   " If 0, then uses value of 'tabstop'
set softtabstop=-1 " If negative, then uses 'shiftwidth' (which can use 'tabstop')
set tabstop=4
set textwidth=79

set foldmethod=indent
set foldtext=MyFoldText()
set nofoldenable

function! MyFoldText() abort
  return "+-" . v:folddashes . " " . printf("%3d", v:foldend - v:foldstart + 1) . " lines: "
        \ . trim(substitute(getline(v:foldstart), split(&l:fmr, ',')[0].'\d\?', '', '')) . " "
endfunction

let &statusline = ""
      \ . "{%{stl#NumOfBufs()}}" . "%{stl#ModifBufs()}" . "  %<%-25.25f "
      \ . "%y" . '[%{&ff};%{(&fenc == "" ? &enc : &fenc).(&bomb ? ",B" : "")}]'
      \ . "%5r  [%{stl#IssuesCount()}]    %5l/%L" . ":%c "

" PLUGINS {{{1

let g:plugins = #{
      \   repos: [
      \     "ctrlpvim/ctrlp.vim",
      \     "dense-analysis/ale",
      \     "Jorengarenar/miniSnip",
      \     "jpalardy/vim-slime",
      \     "majutsushi/tagbar",
      \     "mbbill/undotree",
      \     "prabirshrestha/vim-lsp",
      \     "puremourning/vimspector",
      \   ],
      \   files: [
      \     [ "autoload/lsp/ale.vim",  "https://git.io/J1zIG" ],
      \     [ "autoload/repeat.vim",   "https://git.io/JmdpI" ],
      \     [ "plugin/commentary.vim", "https://git.io/JGOEP" ],
      \     [ "plugin/fastfold.vim",   "https://git.io/JIEo6" ],
      \     [ "plugin/surround.vim",   "https://git.io/JLXyW" ],
      \     [ "syntax/tex.vim",        "https://git.io/JYBDH" ],
      \   ]
      \ }

packadd cfilter
packadd matchit
source  $VIMRUNTIME/ftplugin/man.vim

" ALE {{{2

let g:ale_disable_lsp      = 1
let g:ale_echo_msg_format  = '[%linter%]: %s'
let g:ale_set_quickfix     = 1
let g:ale_set_signs        = 0

hi! link ALEError   Error
hi! link ALEWarning WarningMsg

nnoremap <F2> :ALEToggle<CR>

augroup LSP_ALE
    autocmd!
    autocmd User lsp_buffer_enabled
          \  call lsp#ale#enable()
          \| let b:ale_linters = get(b:, "ale_linters", []) + [ 'vim-lsp' ]
          \| ALELint

    let g:lsp_ale_diagnostics_severity = 'information'
    let g:lsp_ale_auto_enable_linter   = 0
augroup END

" vim-lsp {{{2

let g:lsp_diagnostics_highlights_enabled     = 1
let g:lsp_diagnostics_highlights_delay       = 0
let g:lsp_diagnostics_signs_enabled          = 0
let g:lsp_document_code_action_signs_enabled = 0

hi! link LspErrorHighlight   Error
hi! link LspWarningHighlight WarningMsg

function! s:lsp_init() abort
  setlocal omnifunc=lsp#complete
  if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif

  nmap <buffer> gd <Plug>(lsp-definition)
  nmap <buffer> gs <Plug>(lsp-document-symbol-search)
  nmap <buffer> gS <Plug>(lsp-workspace-symbol-search)
  nmap <buffer> gr <Plug>(lsp-references)
  nmap <buffer> gi <Plug>(lsp-implementation)
  nmap <buffer> <leader>gt <Plug>(lsp-type-definition)
  nmap <buffer> <leader>R <Plug>(lsp-rename)
  nmap <buffer> [g <Plug>(lsp-previous-diagnostic)
  nmap <buffer> ]g <Plug>(lsp-next-diagnostic)
  nmap <buffer> <leader>k <Plug>(lsp-hover)
  inoremap <buffer> <expr><C-f> lsp#scroll(+4)
  inoremap <buffer> <expr><C-d> lsp#scroll(-4)
endfunction

augroup LSP
  autocmd!
  autocmd User lsp_buffer_enabled call s:lsp_init()

  if executable("ccls")
    au User lsp_setup call lsp#register_server(#{
          \   name: "ccls",
          \   cmd: [ "ccls" ],
          \   root_uri: {server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), "compile_commands.json"))},
          \   initialization_options: #{
          \     cache: #{ directory: "/tmp/ccls-cache" },
          \     clang: #{ extraArgs: [
          \       "--gcc-toolchain=/usr",
          \       "-D LSP",
          \     ] },
          \   },
          \   allowlist: [ "c", "cpp", "objc", "objcpp" ],
          \ })
  endif

  if executable("jedi-language-server")
    au User lsp_setup call lsp#register_server(#{
          \   name: "Jedi",
          \   cmd: [ "jedi-language-server" ],
          \   allowlist: [ "python" ],
          \ })
  endif

  if executable("texlab")
    au User lsp_setup call lsp#register_server(#{
          \   name: "TexLab",
          \   cmd: [ "texlab" ],
          \   allowlist: [ "tex" ],
          \ })
  endif

  if executable("sqls")
    au User lsp_setup call lsp#register_server(#{
          \   name: "sqls",
          \   cmd: [ "sqls" ],
          \   command: "sqls",
          \   workspace_config: #{
          \     sqls: #{
          \       connections: [
          \         #{
          \           driver: "sqlite3",
          \           dataSourceName: $SQLS_SQLITE_DB,
          \         },
          \         #{
          \           driver: "mysql",
          \           proto:  "unix",
          \           user:   empty($SQLS_MYSQL_USER) ? $USER : $SQLS_MYSQL_USER,
          \           passwd: $SQLS_MYSQL_PASSWD,
          \           path:   "/run/mysqld/mysqld.sock",
          \           dbName: $SQLS_MYSQL_DB,
          \         },
          \       ],
          \     },
          \   },
          \   allowlist: [ "sql" ]
          \ })
  endif

  if executable("jdtls")
    au User lsp_setup call lsp#register_server(#{
          \   name: "Eclipse JDT Language Server",
          \   cmd: [ "jdtls" ],
          \   allowlist: [ "java" ],
          \ })
  endif

  if executable("deno")
    au User lsp_setup call lsp#register_server(#{
          \   name: "Deno",
          \   cmd: [ "deno", "lsp" ],
          \   initialization_options: #{
          \     enable: v:true,
          \     unstable: v:true,
          \     lint: v:true,
          \     codeLens: #{
          \       implementations: v:true,
          \       references: v:true,
          \       referencesAllFunctions: v:true,
          \       test: v:true,
          \     },
          \     suggest: #{
          \       names: v:true,
          \     },
          \   },
          \   allowlist: [ "javascript", "typescript" ],
          \ })
  endif

augroup END

" Surround {{{2

let g:surround_no_mappings = 1

xmap s  <Plug>VSurround
nmap s  <Plug>Ysurround
nmap ds <Plug>Dsurround
nmap cs <Plug>Csurround
nmap ss <Plug>Yssurround

" CtrlP {{{2

let g:ctrlp_cache_dir           = $XDG_CACHE_HOME . "/vim/ctrlp"
let g:ctrlp_types               = [ 'fil', 'buf' ]

let g:ctrlp_prompt_mappings = {
    \ 'PrtExit()':     [ '<Esc>' ],
    \ 'PrtHistory(1)': [ '<C-f>' ],
    \ 'ToggleType(1)': [ '<C-p>', '<c-up>' ],
    \ }

" Netrw {{{2

let g:netrw_banner       = 0    " do not display info on the top of window
let g:netrw_liststyle    = 3    " tree-view
let g:netrw_browse_split = 4    " use the previous window to open file
let g:netrw_winsize      = -28  " window size

augroup NETRW_CONF
  autocmd!
  autocmd filetype netrw silent! unmap <buffer> <F1>
  autocmd filetype netrw silent! unmap <buffer> <C-l>
  autocmd filetype netrw setlocal statusline=%f
augroup END

" Tagbar {{{2

nnoremap <Leader>t :Tagbar<CR>

let g:tagbar_compact = 1
let g:tagbar_sort    = 0

hi! link TagbarNestedKind Comment
hi! link TagbarType Comment

" vim-slime {{{2

let g:slime_dont_ask_default = 1
let g:slime_no_mappings = 1
let g:slime_paste_file = tempname()

if has("nvim")
  let g:slime_target = "neovim"
elseif has("terminal")
  let g:slime_target = "vimterminal"
elseif executable("tmux")
  let g:slime_target = "tmux"
elseif !empty($DISPLAY)
  let g:slime_target = "x11"
endif

function! Slimeify()
  let g:slime_default_config = get(g:, "slime_default_config", {})

  let foo = {
        \   "vimterminal": [ "bufnr", "bufnr()"  ],
        \   "neovim":      [ "jobid", "&channel" ],
        \ }

  let st = get(g:, "slime_target", "")
  if has_key(foo, st)
    let [ target, y ] = foo[st]
    let g:slime_default_config[target] = eval(y)
  endif
endfunction

com! -nargs=+ -bang  Slime  call slime#send(<q-args> . (<bang>0 ? "" : "\r"))

noremap  <F5> :SlimeSend<CR>
tnoremap <F5> <C-\><C-n>:call Slimeify()<CR>a

" ~ {{{2

let g:fastfold_fold_command_suffixes = [ 'C', 'm', 'M', 'N', 'x', 'X' ]
let g:fastfold_minlines              = 0
let g:fastfold_savehook              = 0

let g:miniSnip_extends = {
      \   "arduino"  : [ "cpp", "c" ],
      \   "cpp"      : [ "c" ],
      \   "html"     : [ "css", "javascript" ],
      \   "markdown" : [ "html" ],
      \   "php"      : [ "html" ],
      \   "tex"      : [ "plaintex" ],
      \ }

let g:undotree_SetFocusWhenToggle = 1
nnoremap <F1> :UndotreeToggle<CR>

let g:vimspector_base_dir        = $XDG_DATA_HOME . '/vim/vimspector'
let g:vimspector_install_gadgets = [ 'debugpy', 'vscode-cpptools' ]

" }}}2

" ~ {{{1

augroup OTHER
  autocmd!

  " Open file at the last known position
  autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' | exec "norm! g`\"" | endif

  " Automatically open QuickFix
  autocmd QuickFixCmdPost [^l]* nested cwindow
  autocmd QuickFixCmdPost    l* nested lwindow

  " Undo if filter shell command returned an error
  autocmd ShellFilterPost * if v:shell_error | undo | endif

  " If file has more lines than window height, then fold it
  autocmd BufReadPost * if line('$') > winheight(0) | setlocal fen | endif

  " Set fold method to syntax
  autocmd FileType dosini,make,m3u  setlocal foldmethod=syntax

augroup END

augroup TRIM_TRAILING_WHITESPACE
  autocmd!
  autocmd BufWritePre * sil! undoj | %s/\v(\s+$|\_s+%$)//e | call histdel("/", -1)
augroup END

augroup TERMINAL_OPTIONS
  autocmd!

  execute 'autocmd '.(has("nvim") ? "TermOpen" : "TerminalOpen").' *'
        \ . ' setlocal nonu stl=%#StatusLineTerm#\ %t '

  if has('nvim') " Sanitize Neovim :terminal
    autocmd TermOpen  * startinsert
    autocmd TermOpen  * let b:term_job_finished = 0
    autocmd TermEnter * if  b:term_job_finished | call feedkeys("\<C-\>\<C-n>") | endif
    autocmd TermClose * let b:term_job_finished = 1 | call feedkeys("\<C-\>\<C-n>")
  endif

augroup END

if has("cscope") && executable("cscope")
  let db = findfile("cscope.out", ".git;")
  if !empty(db)
    let [ csverb_old, &cscopeverbose ] = [ &cscopeverbose, 0 ]
    exe "cs add ".db." ".strpart(db, 0, match(db, ".git/cscope.out$"))
    let &cscopeverbose = csverb_old
    unlet csverb_old
  elseif filereadable("cscope.out")
    cs add cscope.out
  elseif $CSCOPE_DB
    cs add $CSCOPE_DB
  endif

  set cscopetag
  set cscopetagorder=0
  set cscopepathcomp=2

  nnoremap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
  nnoremap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>
  nnoremap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>
  nnoremap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>
  nnoremap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>
  nnoremap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
  nnoremap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
  nnoremap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>
  nnoremap <C-\>a :cs find a <C-R>=expand("<cword>")<CR><CR>

  nnoremap <C-\><C-i> :cs find i ^%:t$<CR>
endif

hi! Dimmer ctermfg=244

set secure
if filereadable("./.vimrc") | source ./.vimrc | endif
